"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Utils = __importStar(require("./index"));
var lodash_1 = __importDefault(require("lodash"));
describe("parseTemplate", function () {
    test("no placeholders returns same", function () {
        var test = "sphinx of black quartz; judge my vow!";
        expect(Utils.parseTemplate(test)).toEqual("sphinx of black quartz; judge my vow!");
    });
    test("single placeholder with 1 option - use that option", function () {
        var test = "sphinx of {black} quartz; judge my vow!";
        expect(Utils.parseTemplate(test)).toEqual("sphinx of black quartz; judge my vow!");
    });
    test("multiple placeholders, each with 1 option - use those options", function () {
        var test = "{sphinx} of {black} quartz; judge {my} {vow}!";
        expect(Utils.parseTemplate(test)).toEqual("sphinx of black quartz; judge my vow!");
    });
    test("placeholder with 2 options", function () {
        var test = "sphinx of {black/green} quartz; judge my vow!";
        var tracker = {
            "sphinx of black quartz; judge my vow!": 0,
            "sphinx of green quartz; judge my vow!": 0
        };
        for (var i = 0; i < 100; i++) {
            var parsed = Utils.parseTemplate(test);
            tracker[parsed] += 1;
        }
        expect(tracker["sphinx of black quartz; judge my vow!"]).toBeGreaterThan(0);
        expect(tracker["sphinx of green quartz; judge my vow!"]).toBeGreaterThan(0);
    });
    test("placeholder with variable replacements", function () {
        var test = "sphinx of {$colour} quartz; judge my vow!";
        expect(Utils.parseTemplate(test, {
            colour: "green"
        })).toEqual("sphinx of green quartz; judge my vow!");
    });
    test("placeholder with multiple variable replacements", function () {
        var test = "sphinx of {$colour} quartz; judge my {$action}!";
        expect(Utils.parseTemplate(test, {
            colour: "green",
            action: "hat"
        })).toEqual("sphinx of green quartz; judge my hat!");
    });
    test("placeholder with options and multiple variable replacements", function () {
        var test = "{sphinx/lion} of {$colour} quartz; judge my {$action}!";
        var tracker = {
            "sphinx of green quartz; judge my hat!": 0,
            "lion of green quartz; judge my hat!": 0
        };
        for (var i = 0; i < 100; i++) {
            var parsed = Utils.parseTemplate(test, {
                colour: "green",
                action: "hat"
            });
            tracker[parsed] += 1;
        }
        expect(tracker["sphinx of green quartz; judge my hat!"]).toBeGreaterThan(0);
        expect(tracker["lion of green quartz; judge my hat!"]).toBeGreaterThan(0);
    });
    test("linked placeholders", function () {
        var test = "the spell was {HEAT::fire/ice} - this made it {HEAT::hot/cold}";
        var tracker = {
            "the spell was fire - this made it hot": 0,
            "the spell was ice - this made it cold": 0,
            "the spell was fire - this made it cold": 0,
            "the spell was ice - this made it hot": 0 // should stay zero
        };
        for (var i = 0; i < 100; i++) {
            var parsed = Utils.parseTemplate(test);
            tracker[parsed] += 1;
        }
        expect(tracker["the spell was fire - this made it hot"]).toBeGreaterThan(0);
        expect(tracker["the spell was ice - this made it cold"]).toBeGreaterThan(0);
        expect(tracker["the spell was fire - this made it cold"]).toEqual(0);
        expect(tracker["the spell was ice - this made it hot"]).toEqual(0);
    });
    test("linked placeholders - including normal placeholders", function () {
        var test = "the spell was {weak/strong} and {HEAT::fire/ice} - this made it {HEAT::hot/cold}";
        var tracker = {
            "the spell was weak and fire - this made it hot": 0,
            "the spell was strong and fire - this made it hot": 0,
            "the spell was weak and ice - this made it cold": 0,
            "the spell was strong and ice - this made it cold": 0,
            "the spell was weak and fire - this made it cold": 0,
            "the spell was strong and fire - this made it cold": 0,
            "the spell was weak and ice - this made it hot": 0,
            "the spell was strong and ice - this made it hot": 0 // should stay zero
        };
        for (var i = 0; i < 100; i++) {
            var parsed = Utils.parseTemplate(test);
            tracker[parsed] += 1;
        }
        expect(tracker["the spell was weak and fire - this made it hot"]).toBeGreaterThan(0);
        expect(tracker["the spell was strong and fire - this made it hot"]).toBeGreaterThan(0);
        expect(tracker["the spell was weak and ice - this made it cold"]).toBeGreaterThan(0);
        expect(tracker["the spell was strong and ice - this made it cold"]).toBeGreaterThan(0);
        expect(tracker["the spell was weak and fire - this made it cold"]).toEqual(0);
        expect(tracker["the spell was strong and fire - this made it cold"]).toEqual(0);
        expect(tracker["the spell was weak and ice - this made it hot"]).toEqual(0);
        expect(tracker["the spell was strong and ice - this made it hot"]).toEqual(0);
    });
    test("linked placeholders - including normal placeholders AND reference placeholders", function () {
        var test = "the spell was {weak/strong} and {$size} and {HEAT::fire/ice} - this made it {HEAT::hot/cold} and {$colour}";
        var tracker = {
            "the spell was weak and big and fire - this made it hot and blue": 0,
            "the spell was strong and big and fire - this made it hot and blue": 0,
            "the spell was weak and big and ice - this made it cold and blue": 0,
            "the spell was strong and big and ice - this made it cold and blue": 0,
            "the spell was weak and big and fire - this made it cold and blue": 0,
            "the spell was strong and big and fire - this made it cold and blue": 0,
            "the spell was weak and big and ice - this made it hot and blue": 0,
            "the spell was strong and big and ice - this made it hot and blue": 0 // should stay zero
        };
        for (var i = 0; i < 100; i++) {
            var parsed = Utils.parseTemplate(test, {
                size: "big",
                colour: "blue"
            });
            tracker[parsed] += 1;
        }
        expect(tracker["the spell was weak and big and fire - this made it hot and blue"]).toBeGreaterThan(0);
        expect(tracker["the spell was strong and big and fire - this made it hot and blue"]).toBeGreaterThan(0);
        expect(tracker["the spell was weak and big and ice - this made it cold and blue"]).toBeGreaterThan(0);
        expect(tracker["the spell was strong and big and ice - this made it cold and blue"]).toBeGreaterThan(0);
        expect(tracker["the spell was weak and big and fire - this made it cold and blue"]).toEqual(0);
        expect(tracker["the spell was strong and big and fire - this made it cold and blue"]).toEqual(0);
        expect(tracker["the spell was weak and big and ice - this made it hot and blue"]).toEqual(0);
        expect(tracker["the spell was strong and big and ice - this made it hot and blue"]).toEqual(0);
    });
});
describe("pick", function () {
    test("pick an item from array", function () {
        var items = ["a", "b", "c"];
        var item = Utils.pick(items);
        expect(typeof item).toBe("string");
        expect(item.length).toBe(1);
        expect(items).toContain(item);
    });
    test("pick a different item each time", function () {
        var items = ["a", "b", "c"];
        var tracker = { a: 0, b: 0, c: 0 };
        for (var i = 0; i < 100; i++) {
            var item = Utils.pick(items);
            tracker[item] += 1;
        }
        expect(tracker["a"]).toBeGreaterThan(0);
        expect(tracker["b"]).toBeGreaterThan(0);
        expect(tracker["c"]).toBeGreaterThan(0);
    });
    test("pick 2 items", function () {
        var items = ["a", "b", "c"];
        var picked = Utils.pickMany(items, 2);
        expect(typeof picked).toBe("object");
        expect(Array.isArray(picked)).toBe(true);
        expect(picked.length).toBe(2);
        expect(items).toContain(picked[0]);
        expect(items).toContain(picked[1]);
    });
    test("pick 3 items", function () {
        var items = ["a", "b", "c"];
        var picked = Utils.pickMany(items, 3);
        expect(typeof picked).toBe("object");
        expect(Array.isArray(picked)).toBe(true);
        expect(picked.length).toBe(3);
        expect(items).toContain(picked[0]);
        expect(items).toContain(picked[1]);
        expect(items).toContain(picked[2]);
        // make sure they're not the same
        expect(picked[0]).not.toBe(picked[1]);
        expect(picked[0]).not.toBe(picked[2]);
        expect(picked[1]).not.toBe(picked[2]);
        // make sure they're all unique
        expect(lodash_1.default.uniq(picked).length).toBe(3);
    });
});
describe("forCount", function () {
    test("add value to outside array", function () {
        var vals = [];
        Utils.forCount(2, function () {
            vals.push("a");
        });
        expect(vals.length).toBe(2);
        expect(vals[0]).toBe("a");
        expect(vals[1]).toBe("a");
    });
});
describe("titleCase", function () {
    test("single word negative", function () {
        expect(Utils.titleCase("alpha")).not.toEqual("alpha");
    });
    test("single word", function () {
        expect(Utils.titleCase("alpha")).toEqual("Alpha");
    });
    test("multiple words", function () {
        expect(Utils.titleCase("alpha beta gamma")).toEqual("Alpha Beta Gamma");
    });
    test("hyphens dont count as word breaks", function () {
        expect(Utils.titleCase("half-orc")).toEqual("Half-orc");
    });
});
describe("formatRace", function () {
    test("PHB races", function () {
        expect(Utils.formatRace("dragonborn")).toEqual("Dragonborn");
        expect(Utils.formatRace("dwarf")).toEqual("Dwarf");
        expect(Utils.formatRace("elf")).toEqual("Elf");
        expect(Utils.formatRace("gnome")).toEqual("Gnome");
        expect(Utils.formatRace("halfElf")).toEqual("Half-Elf");
        expect(Utils.formatRace("halfOrc")).toEqual("Half-Orc");
        expect(Utils.formatRace("halfling")).toEqual("Halfling");
        expect(Utils.formatRace("human")).toEqual("Human");
        expect(Utils.formatRace("tiefling")).toEqual("Tiefling");
    });
});
describe("generateUUID", function () {
    test("generate some uuids that are different and the correct length", function () {
        var uuid = Utils.generateUUID();
        expect(uuid.length).toEqual(36);
        var uuid2 = Utils.generateUUID();
        expect(uuid2).not.toEqual(uuid);
        expect(uuid2.length).toEqual(36);
    });
});
