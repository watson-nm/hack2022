"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var seedrandom_1 = __importDefault(require("seedrandom"));
var RandomFunction = Math.random;
/**
 * pick 1 unique values from an array, and return that value
 *
 * @param {any[]} array an array of values to pick from
 */
exports.pick = function (array) {
    return exports.pickMany(array, 1)[0];
};
/**
 * pick 1 or more unique values from an array, and return a new array of those picked values
 *
 * @param {any[]} array an array of values to pick from
 * @param {number} count how many unique array values to pick out
 */
exports.pickMany = function (array, count) {
    if (count === void 0) { count = 1; }
    var arrayCopy = Array.from(array);
    var pickedValues = [];
    for (var i = 0; i < count; i++) {
        var pickedIndex = exports.rand(0, arrayCopy.length - 1);
        pickedValues.push(arrayCopy[pickedIndex]);
        arrayCopy.splice(pickedIndex, 1);
    }
    return pickedValues;
};
exports.randomRace = function () { };
exports.randomGender = function () {
    return exports.pick(["male", "female"]);
};
/**
 * parse our special template syntax
 *
 * handles multiple "kinds" of template syntax
 *
 * a string containing '{alpha/beta}' will choose one at random
 *
 * a string starting with a $ symbol is a reference for any passed content
 *   so '{$colour}' becomes 'blue' if `content` was passed as { colour: 'blue' }
 *
 * a string container using the linked format (symbol, double colon) e.g {X::aplha/beta}
 *   will ensure that any other placeholder in the string that uses the same linked symbol
 *   returns the same index of random that the first placeholder with that symbol did
 *
 * @param {string} string
 */
exports.parseTemplate = function (string, content) {
    if (content === void 0) { content = {}; }
    var regex = /{(.+?)}/gm;
    var matches = string.match(regex);
    var linkedPlaceholderIndexes = {};
    if (matches) {
        // is our match a placeholder setup
        matches.forEach(function (match) {
            var linkedPlaceholderMatches = /{(.+?)::(.+?)}/gm.exec(match);
            if (linkedPlaceholderMatches) {
                var rawLinkToken = linkedPlaceholderMatches[1];
                if (linkedPlaceholderIndexes[rawLinkToken] != null) {
                    // if we're already setup
                    var replacement = linkedPlaceholderMatches[2].split("/")[linkedPlaceholderIndexes[rawLinkToken]];
                    string = string.replace(match, replacement);
                }
                else {
                    // if not, we need to do the first one and add the index into the linkedPlaceholderIndexes
                    var allPlaceholderChunks = linkedPlaceholderMatches[2].split("/");
                    var newIndex = exports.rand(0, allPlaceholderChunks.length - 1);
                    var replacement = allPlaceholderChunks[newIndex];
                    linkedPlaceholderIndexes[rawLinkToken] = newIndex; // set it up for further matches
                    string = string.replace(match, replacement);
                }
            }
        });
        matches.forEach(function (match) {
            if (match.charAt(1) === "$") {
                var replacementVarName = match.substring(2, match.length - 1);
                string = string.replace(match, content[replacementVarName]);
            }
            else {
                var replacement = exports.pick(match
                    .substring(1)
                    .substring(0, match.length - 2)
                    .split("/"));
                string = string.replace(match, replacement);
            }
        });
    }
    return string;
};
/**
 * generate a random number between 2 inclusive values
 *
 * @param {number} min minimum number to return (inclusive)
 * @param {number} max maximum number to return (inclusive)
 * @param {any} seed
 */
exports.rand = function (min, max) {
    min = parseInt(min);
    max = parseInt(max);
    return Math.floor(RandomFunction() * (max - min + 1)) + min;
};
/**
 *
 * @param {number} number
 * @param {function} func
 */
exports.forCount = function (number, func) {
    for (var i = 0; i < number; i++) {
        func();
    }
};
// make every word in a sentence have a capital letter
exports.titleCase = function (string) {
    return string.replace(/_/g, " ").replace(/\w\S*/g, function (txt) {
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
    });
};
exports.firstCharacterUppercase = function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
};
exports.formatRace = function (race) {
    switch (race) {
        case "halfOrc":
            return "Half-Orc";
        case "halfElf":
            return "Half-Elf";
        default:
            return exports.titleCase(race);
    }
};
exports.generateUUID = function () {
    // Public Domain/MIT
    var d = new Date().getTime();
    if (typeof performance !== "undefined" &&
        typeof performance.now === "function") {
        d += performance.now(); //use high-precision timer if available
    }
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
        var r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c === "x" ? r : (r & 0x3) | 0x8).toString(16);
    });
};
exports.withSeed = function (seed, callback) {
    var isFirstPass = exports.FantasyContentGeneratorSeed == null;
    exports.FantasyContentGeneratorSeed = seed;
    RandomFunction = seedrandom_1.default(exports.FantasyContentGeneratorSeed);
    var returnValue = callback();
    if (isFirstPass) {
        exports.FantasyContentGeneratorSeed = null;
        RandomFunction = Math.random;
    }
    return returnValue;
};
